/// <reference types="node" />
/**
 * Dive EA REST API
 * Dive Experience Amplifier REST API provides a set of services which leverage obtaining catalog and TV grid info, contextual items (cards) information and saving and a static (scene by scene) version of the card carousel for linear TV and video on demand
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://rest.dive.tv/v1".replace(/\/+$/, "");

export type TokenStoreType = "webstorage" | "cookies";

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: any;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

export interface AccessToken {
    /**
     * Auth token, must be included on every API request
     */
    "access_token"?: string;
    /**
     * Token type
     */
    "token_type"?: AccessTokenTokenTypeEnum;
    /**
     * Allows to issue new access tokens without resending client credentials
     */
    "refresh_token"?: string;
    /**
     * Expiration time (in seconds).
     */
    "expires_in"?: number;
    /**
     * Granted auth scope
     */
    "scope"?: AccessTokenScopeEnum;
}

export type AccessTokenTokenTypeEnum = "bearer";
export type AccessTokenScopeEnum = "device";
export interface AuthError {
    /**
     * Short error identifier
     */
    "error"?: string;
    /**
     * Extended error description
     */
    "error_description"?: string;
}

/**
 * Award nominee or winner info
 */
export interface AwardData {
    /**
     * Name of the prize
     */
    "title": string;
    /**
     * Name of the nominee / winner
     */
    "value": string;
}

export interface AwardsData {
    /**
     * Award name
     */
    "title": string;
    "nominee"?: Array<AwardData>;
    "winner"?: Array<AwardData>;
}

/**
 * Basic Dive data unit, represents an item of a given category
 */
export interface Card {
    /**
     * Card unique identifier
     */
    "card_id": string;
    /**
     * Card version for a given movie and scene
     */
    "version"?: string;
    /**
     * Card type
     */
    "type": CardTypeEnum;
    /**
     * Card content locale
     */
    "locale": string;
    /**
     * Card title
     */
    "title": string;
    /**
     * Card subtitle (might be empty)
     */
    "subtitle"?: string;
    "image"?: ImageData;
    /**
     * Indicates if the card has additional browsable content
     */
    "has_content"?: boolean;
    "info"?: Array<CardContainer>;
    /**
     * Commercial products associated to the card
     */
    "products"?: Array<Product>;
    "relations"?: Array<RelationModule>;
    "user"?: CardUser;
}

export type CardTypeEnum = "movie" | "serie" | "person" | "character" | "vehicle" | "fashion" | "location" | "historic" | "trivia" | "quote" | "ost" | "home" | "technology" | "art" | "song" | "look" | "weapon" | "leisure_sport" | "health_beauty" | "food_drink" | "fauna_flora" | "business" | "reference" | "chapter";
/**
 * Card static data container. It's content depends on the 'type' parameter value and is represented by the schema of the same name
 */
export interface CardContainer {
    /**
     * Card container format type, determines the format of the 'data' field
     */
    "type": CardContainerTypeEnum;
}

export type CardContainerTypeEnum = "text" | "listing" | "rating" | "map" | "link" | "awards" | "catalog" | "seasons" | "image";
/**
 * Contains user interaction attributes relative to this card
 */
export interface CardUser {
    /**
     * Indicates if user has liked the card or not
     */
    "is_liked": boolean;
}

export interface CatalogData {
    /**
     * URL of an additional background image for this catalog element
     */
    "background_image"?: string;
    /**
     * Name of the director
     */
    "director": string;
    /**
     * List of genres of this catalog entry
     */
    "genres": Array<string>;
    /**
     * Original language title
     */
    "original_title": string;
    /**
     * Length of the movie or chapter, or average length of serie chapters, in minutes
     */
    "runtime": number;
    /**
     * Year of production
     */
    "year": number;
    /**
     * Index of the chapter inside its season (only for content_type=chapter)
     */
    "chapter_index"?: number;
    /**
     * Index of the season where the chapter belongs (only for content_type=chapter)
     */
    "season_index"?: number;
    "sync"?: CatalogSync;
}

/**
 * Dive interactive capabilities of this catalog item
 */
export interface CatalogSync {
    /**
     * Indicates if this catalog item can be synchronized
     */
    "is_synchronizable": boolean;
}

export interface ChannelStatus {
    /**
     * Provided channel ID
     */
    "channel_id"?: string;
    /**
     * True if channel is broadcasting synchronizable content, False otherwise
     */
    "ready"?: boolean;
}

export interface DupleData {
    /**
     * Indicates the relationship between the pair of cards (from > rel_type > to)
     */
    "rel_type": DupleDataRelTypeEnum;
    "from": Card;
    "to"?: Card;
}

export type DupleDataRelTypeEnum = "plays" | "starred_by" | "represents" | "features_location" | "directs" | "acts_in" | "played_by" | "worn_by" | "filmed_in" | "location_on_movie";
/**
 * Linked image URL and additional information
 */
export interface ImageData {
    /**
     * Image thumbnail URL
     */
    "thumb": string;
    /**
     * Full size image URL
     */
    "full": string;
    /**
     * Image anchor X axis (percent)
     */
    "anchor_x": number;
    /**
     * Image anchor Y axis (percent)
     */
    "anchor_y": number;
    "source": SourceData;
}

export interface LinkData {
    /**
     * URL of the external resource
     */
    "url": string;
    "source": SourceData;
}

export interface ListingData {
    /**
     * Item label
     */
    "text": string;
    /**
     * Item value
     */
    "value": string;
}

export interface MapData {
    /**
     * Value of the location latitude, in decimal format degrees
     */
    "latitude": number;
    /**
     * Value of the location longitude, in decimal format degrees
     */
    "longitude": number;
    /**
     * Zoom value, defines the height coordinate over the given location
     */
    "zoom": number;
}

export interface MovieStatus {
    /**
     * Provided client movie ID
     */
    "movie_id"?: string;
    /**
     * True if movie can be synchronized via this API, False otherwise.
     */
    "ready"?: boolean;
}

/**
 * Commercial product data
 */
export interface Product {
    /**
     * Product identifier
     */
    "product_id": string;
    /**
     * Merchant category
     */
    "category": ProductCategoryEnum;
    "source"?: SourceData;
    /**
     * Product title
     */
    "title": string;
    /**
     * Product image URL
     */
    "image": string;
    /**
     * Merchant store URL
     */
    "url": string;
    /**
     * Product price
     */
    "price"?: number;
    /**
     * Product price currency
     */
    "currency"?: string;
    /**
     * Indicates if product in up to date on Dive database
     */
    "is_up_to_date"?: boolean;
    /**
     * Indicates if product is an exact match
     */
    "is_exact"?: boolean;
    /**
     * Country information. Only for travel products
     */
    "country"?: string;
    /**
     * Region information. Only for travel products
     */
    "region"?: string;
    /**
     * City information. Only for travel products
     */
    "city"?: string;
    /**
     * Address information. Only for travel products
     */
    "address"?: string;
    /**
     * Postal code information. Only for travel products
     */
    "postal_code"?: string;
    /**
     * Rating information. Only for travel products
     */
    "rating"?: number;
}

export type ProductCategoryEnum = "fashion" | "electro" | "merch" | "travel";
export interface RatingData {
    /**
     * Rating value
     */
    "value": string;
    "source"?: SourceData;
}

/**
 * Relation modules provide lists of cards related to the current one. It's contents depend on the module 'type' attribute
 */
export interface RelationModule {
    /**
     * Relation module type, defines the contained data structure
     */
    "type": RelationModuleTypeEnum;
}

export type RelationModuleTypeEnum = "single" | "duple";
export interface SeasonsChapters {
    /**
     * Index of the chapter inside this season
     */
    "chapter_index": number;
    /**
     * ID of the chapter card
     */
    "card_id": string;
}

export interface SeasonsData {
    /**
     * Index of the season
     */
    "season_index": number;
    /**
     * Comma separated list of season creators
     */
    "creators": string;
    "image": ImageData;
    /**
     * Year of production of this season
     */
    "year": number;
    /**
     * List of season chapters
     */
    "chapters": Array<SeasonsChapters>;
}

/**
 * Information regarding the source of any API item
 */
export interface SourceData {
    /**
     * Name of the source
     */
    "name": string;
    /**
     * URL of the source
     */
    "url": string;
    /**
     * Disclaimer text of the source
     */
    "disclaimer"?: string;
    /**
     * URL of the source icon
     */
    "image"?: string;
}

export interface TextData {
    /**
     * Informational text
     */
    "text": string;
    "source"?: SourceData;
}

/**
 * TV event information
 */
export interface TvEvent {
    /**
     * TV channel ID where the the event is schedulled
     */
    "channel_id": string;
    /**
     * TV channel name
     */
    "channel_name": string;
    /**
     * TV event start date in milliseconds since EPOCH
     */
    "start_date": number;
    /**
     * TV event end date in milliseconds since EPOCH
     */
    "end_date": number;
    /**
     * Associated content (movie or chapter) card
     */
    "card": Card;
}

/**
 * TV grid information
 */
export interface TvGrid {
    /**
     * List of TV events currently being broadcasted
     */
    "broadcast": Array<TvEvent>;
    /**
     * List of upcoming TV events
     */
    "upcoming": Array<TvEvent>;
}

/**
 * CardContainer composed by a list of awards with nominees and winners
 */
export interface Awards extends CardContainer {
    /**
     * Awards container content type
     */
    "content_type": AwardsContentTypeEnum;
    "data": Array<AwardsData>;
}

export type AwardsContentTypeEnum = "awards";
/**
 * CardContainer composed by additional information of a catalog item (movie, serie or chapter)
 */
export interface Catalog extends CardContainer {
    /**
     * Catalog container content type
     */
    "content_type": CatalogContentTypeEnum;
    "data": Array<CatalogData>;
}

export type CatalogContentTypeEnum = "movie" | "chapter" | "serie";
/**
 * List of related pairs of cards, each pair having a relationship type between both cards
 */
export interface Duple extends RelationModule {
    /**
     * Duple module content type, defines what kind of relations are contained in the module
     */
    "content_type": DupleContentTypeEnum;
    "data": Array<DupleData>;
}

export type DupleContentTypeEnum = "movie_locations" | "worn_by" | "casting" | "casting_fashion" | "filmography" | "played_by" | "featured_in";
/**
 * CardContainer composed by a list of images with source attribution
 */
export interface Image extends CardContainer {
    /**
     * Image container content type
     */
    "content_type": ImageContentTypeEnum;
    "data": Array<ImageData>;
}

export type ImageContentTypeEnum = "gallery";
/**
 * CardContainer composed by a list of links to external media resources with source attribution
 */
export interface Link extends CardContainer {
    /**
     * Link container content type
     */
    "content_type": LinkContentTypeEnum;
    "data": Array<LinkData>;
}

export type LinkContentTypeEnum = "trailer" | "video" | "music";
/**
 * CardContainer composed by a list of pairs of label - value items
 */
export interface Listing extends CardContainer {
    /**
     * Listing container content type
     */
    "content_type": ListingContentTypeEnum;
    "data": Array<ListingData>;
}

export type ListingContentTypeEnum = "basic_data" | "specs";
/**
 * CardContainer composed by a map of a given location
 */
export interface Map extends CardContainer {
    /**
     * Map container content type
     */
    "content_type": MapContentTypeEnum;
    "data": Array<MapData>;
}

export type MapContentTypeEnum = "location";
/**
 * CardContainer composed by a list of external ratings with source attribution
 */
export interface Rating extends CardContainer {
    /**
     * Rating container content type
     */
    "content_type": RatingContentTypeEnum;
    "data": Array<RatingData>;
}

export type RatingContentTypeEnum = "rating";
/**
 * Serie seasons listing
 */
export interface Seasons extends CardContainer {
    /**
     * Seasons container content type
     */
    "content_type": SeasonsContentTypeEnum;
    "data": Array<SeasonsData>;
}

export type SeasonsContentTypeEnum = "seasons";
/**
 * List of related single cards. The relation type is defined by the module content type
 */
export interface Single extends RelationModule {
    /**
     * Single module content type, defines what kind of relations are contained in the module
     */
    "content_type": SingleContentTypeEnum;
    "data": Array<Card>;
}

export type SingleContentTypeEnum = "movie_vehicles" | "movie_songs" | "miscellaneous" | "highlighted" | "recommended" | "trivias" | "appears_in" | "tracklist" | "sounds_in" | "full_looks" | "look_fashion" | "fashion_set" | "other_looks" | "wears" | "home_deco" | "full_home" | "is_part_of" | "directors" | "is_chapter_of" | "composed_of" | "owns" | "belongs_to" | "filmed_in" | "represents" | "worn_by" | "plays" | "played_by";
/**
 * CardContainer composed by a block of text with an optional source attribution
 */
export interface Text extends CardContainer {
    /**
     * Text container content type
     */
    "content_type": TextContentTypeEnum;
    "data": Array<TextData>;
}

export type TextContentTypeEnum = "overview" | "curiosity" | "description" | "biography" | "reference" | "quote";


/**
 * DefaultApi - fetch parameter creator
 */
export const DefaultApiFetchParamCreator = {
    /**
     * Removes a card from current user's likes list
     * @summary Delete card like
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Requested card ID
     * @param acceptLanguage Client locale, as language-country
     */
    deleteLikes(params: {  "authorization": string; "cardId": string; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling deleteLikes");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling deleteLikes");
        }
        const baseUrl = `/likes/{card_id}`
            .replace(`{${"card_id"}}`, `${ params["cardId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Accept-Language": params["acceptLanguage"],"Authorization": params["authorization"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieves a full card detail, with no relations or context
     * @summary Full card detail
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Unique identifier for this card
     * @param acceptLanguage Client locale, as language-country
     * @param products Indicates if cards should contain commercial products when available (true) or not (false)
     * @param userData Indicates if cards should contain user data when available (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getCard(params: {  "authorization": string; "cardId": string; "acceptLanguage"?: string; "products"?: boolean; "userData"?: boolean; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getCard");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling getCard");
        }
        const baseUrl = `/cards/{card_id}`
            .replace(`{${"card_id"}}`, `${ params["cardId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "products": params["products"],
            "user_data": params["userData"],
            "image_size": params["imageSize"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieves a full card detail, and its relations to other cards in a given context (card version)
     * @summary Full card detail with version
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Unique identifier for this card
     * @param version Version identifier, indicates the context where the card is being requested
     * @param acceptLanguage Client locale, as language-country
     * @param products Indicates if cards should contain commercial products when available (true) or not (false)
     * @param userData Indicates if cards should contain user data when available (true) or not (false)
     * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getCardVersion(params: {  "authorization": string; "cardId": string; "version": string; "acceptLanguage"?: string; "products"?: boolean; "userData"?: boolean; "relations"?: boolean; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getCardVersion");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling getCardVersion");
        }
        // verify required parameter "version" is set
        if (params["version"] == null) {
            throw new Error("Missing required parameter version when calling getCardVersion");
        }
        const baseUrl = `/cards/{card_id}/versions/{version}`
            .replace(`{${"card_id"}}`, `${ params["cardId"] }`)
            .replace(`{${"version"}}`, `${ params["version"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "products": params["products"],
            "user_data": params["userData"],
            "relations": params["relations"],
            "image_size": params["imageSize"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieves a movie's full card by its client ID, including catalog and cast information
     * @summary Movie catalog info
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     */
    getCatalogMovie(params: {  "authorization": string; "clientMovieId": string; "acceptLanguage"?: string; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getCatalogMovie");
        }
        // verify required parameter "clientMovieId" is set
        if (params["clientMovieId"] == null) {
            throw new Error("Missing required parameter clientMovieId when calling getCatalogMovie");
        }
        const baseUrl = `/movies/{client_movie_id}`
            .replace(`{${"client_movie_id"}}`, `${ params["clientMovieId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "image_size": params["imageSize"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the current and upcoming grid of TV events for the given channel
     * @summary Channel events grid
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     */
    getChannelGrid(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getChannelGrid");
        }
        // verify required parameter "channelId" is set
        if (params["channelId"] == null) {
            throw new Error("Missing required parameter channelId when calling getChannelGrid");
        }
        const baseUrl = `/channels/{channel_id}/grid`
            .replace(`{${"channel_id"}}`, `${ params["channelId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "image_size": params["imageSize"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
     * @summary Channel movie catalog info
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     */
    getChannelMovie(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getChannelMovie");
        }
        // verify required parameter "channelId" is set
        if (params["channelId"] == null) {
            throw new Error("Missing required parameter channelId when calling getChannelMovie");
        }
        const baseUrl = `/channels/{channel_id}`
            .replace(`{${"channel_id"}}`, `${ params["channelId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "image_size": params["imageSize"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns a paginated list of cards liked by current user
     * @summary Get card likes
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     * @param paginateKey Paginate key
     * @param size Number of desired results
     */
    getLikes(params: {  "authorization": string; "acceptLanguage"?: string; "imageSize"?: string; "paginateKey"?: string; "size"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getLikes");
        }
        const baseUrl = `/likes`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "image_size": params["imageSize"],
            "paginate_key": params["paginateKey"],
            "size": params["size"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Accept-Language": params["acceptLanguage"],"Authorization": params["authorization"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
     * @summary Channel sync availability
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelIdList List of client channel IDs as a comma separated list
     * @param acceptLanguage Client locale, as language-country
     */
    getReadyChannels(params: {  "authorization": string; "channelIdList": Array<string>; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getReadyChannels");
        }
        // verify required parameter "channelIdList" is set
        if (params["channelIdList"] == null) {
            throw new Error("Missing required parameter channelIdList when calling getReadyChannels");
        }
        const baseUrl = `/channels/{channel_id_list}/ready`
            .replace(`{${"channel_id_list"}}`, `${ params["channelIdList"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
     * @summary Movie sync availability
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
     * @param acceptLanguage Client locale, as language-country
     */
    getReadyMovies(params: {  "authorization": string; "clientMovieIdList": Array<string>; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getReadyMovies");
        }
        // verify required parameter "clientMovieIdList" is set
        if (params["clientMovieIdList"] == null) {
            throw new Error("Missing required parameter clientMovieIdList when calling getReadyMovies");
        }
        const baseUrl = `/movies/{client_movie_id_list}/ready`
            .replace(`{${"client_movie_id_list"}}`, `${ params["clientMovieIdList"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieves the list of cards related to the content currently being broadcasted in the given channel
     * @summary Static channel scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as language-country
     * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticChannelScene(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getStaticChannelScene");
        }
        // verify required parameter "channelId" is set
        if (params["channelId"] == null) {
            throw new Error("Missing required parameter channelId when calling getStaticChannelScene");
        }
        const baseUrl = `/channels/{channel_id}/static`
            .replace(`{${"channel_id"}}`, `${ params["channelId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "relations": params["relations"],
            "image_size": params["imageSize"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieves the current list of cards related to the given movie scene
     * @summary Static VOD scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param timestamp Current movie timestamp in seconds
     * @param acceptLanguage Client locale, as language-country
     * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticMovieScene(params: {  "authorization": string; "clientMovieId": string; "timestamp": number; "acceptLanguage"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getStaticMovieScene");
        }
        // verify required parameter "clientMovieId" is set
        if (params["clientMovieId"] == null) {
            throw new Error("Missing required parameter clientMovieId when calling getStaticMovieScene");
        }
        // verify required parameter "timestamp" is set
        if (params["timestamp"] == null) {
            throw new Error("Missing required parameter timestamp when calling getStaticMovieScene");
        }
        const baseUrl = `/movies/{client_movie_id}/static/{timestamp}`
            .replace(`{${"client_movie_id"}}`, `${ params["clientMovieId"] }`)
            .replace(`{${"timestamp"}}`, `${ params["timestamp"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "relations": params["relations"],
            "image_size": params["imageSize"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Stores a card under current user's likes list
     * @summary Add card like
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Requested card ID
     * @param acceptLanguage Client locale, as language-country
     */
    postLikes(params: {  "authorization": string; "cardId": string; "acceptLanguage"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postLikes");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling postLikes");
        }
        const baseUrl = `/likes/{card_id}`
            .replace(`{${"card_id"}}`, `${ params["cardId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = Object.assign({
            "Accept-Language": params["acceptLanguage"],"Authorization": params["authorization"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @summary Token endpoint
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token.
     * @param acceptLanguage Client locale, as language-country
     * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "deviceId"?: string; "refreshToken"?: string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postToken");
        }
        // verify required parameter "grantType" is set
        if (params["grantType"] == null) {
            throw new Error("Missing required parameter grantType when calling postToken");
        }
        const baseUrl = `/token`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = Object.assign({}, urlObj.query, {
            "grant_type": params["grantType"],
        });
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "device_id": params["deviceId"],
            "refresh_token": params["refreshToken"],
        });
        fetchOptions.headers = Object.assign({
            "Authorization": params["authorization"],"Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = {
    /**
     * Removes a card from current user's likes list
     * @summary Delete card like
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Requested card ID
     * @param acceptLanguage Client locale, as language-country
     */
    deleteLikes(params: { "authorization": string; "cardId": string; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<any> {
        const fetchArgs = DefaultApiFetchParamCreator.deleteLikes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieves a full card detail, with no relations or context
     * @summary Full card detail
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Unique identifier for this card
     * @param acceptLanguage Client locale, as language-country
     * @param products Indicates if cards should contain commercial products when available (true) or not (false)
     * @param userData Indicates if cards should contain user data when available (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getCard(params: { "authorization": string; "cardId": string; "acceptLanguage"?: string; "products"?: boolean; "userData"?: boolean; "imageSize"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Card> {
        const fetchArgs = DefaultApiFetchParamCreator.getCard(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieves a full card detail, and its relations to other cards in a given context (card version)
     * @summary Full card detail with version
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Unique identifier for this card
     * @param version Version identifier, indicates the context where the card is being requested
     * @param acceptLanguage Client locale, as language-country
     * @param products Indicates if cards should contain commercial products when available (true) or not (false)
     * @param userData Indicates if cards should contain user data when available (true) or not (false)
     * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getCardVersion(params: { "authorization": string; "cardId": string; "version": string; "acceptLanguage"?: string; "products"?: boolean; "userData"?: boolean; "relations"?: boolean; "imageSize"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Card> {
        const fetchArgs = DefaultApiFetchParamCreator.getCardVersion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieves a movie's full card by its client ID, including catalog and cast information
     * @summary Movie catalog info
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     */
    getCatalogMovie(params: { "authorization": string; "clientMovieId": string; "acceptLanguage"?: string; "imageSize"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Card> {
        const fetchArgs = DefaultApiFetchParamCreator.getCatalogMovie(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the current and upcoming grid of TV events for the given channel
     * @summary Channel events grid
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     */
    getChannelGrid(params: { "authorization": string; "channelId": string; "acceptLanguage"?: string; "imageSize"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<TvGrid> {
        const fetchArgs = DefaultApiFetchParamCreator.getChannelGrid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
     * @summary Channel movie catalog info
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     */
    getChannelMovie(params: { "authorization": string; "channelId": string; "acceptLanguage"?: string; "imageSize"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Card> {
        const fetchArgs = DefaultApiFetchParamCreator.getChannelMovie(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns a paginated list of cards liked by current user
     * @summary Get card likes
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     * @param paginateKey Paginate key
     * @param size Number of desired results
     */
    getLikes(params: { "authorization": string; "acceptLanguage"?: string; "imageSize"?: string; "paginateKey"?: string; "size"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<Card>> {
        const fetchArgs = DefaultApiFetchParamCreator.getLikes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
     * @summary Channel sync availability
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelIdList List of client channel IDs as a comma separated list
     * @param acceptLanguage Client locale, as language-country
     */
    getReadyChannels(params: { "authorization": string; "channelIdList": Array<string>; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<ChannelStatus>> {
        const fetchArgs = DefaultApiFetchParamCreator.getReadyChannels(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
     * @summary Movie sync availability
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
     * @param acceptLanguage Client locale, as language-country
     */
    getReadyMovies(params: { "authorization": string; "clientMovieIdList": Array<string>; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<MovieStatus>> {
        const fetchArgs = DefaultApiFetchParamCreator.getReadyMovies(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieves the list of cards related to the content currently being broadcasted in the given channel
     * @summary Static channel scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as language-country
     * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticChannelScene(params: { "authorization": string; "channelId": string; "acceptLanguage"?: string; "relations"?: boolean; "imageSize"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<Card>> {
        const fetchArgs = DefaultApiFetchParamCreator.getStaticChannelScene(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieves the current list of cards related to the given movie scene
     * @summary Static VOD scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param timestamp Current movie timestamp in seconds
     * @param acceptLanguage Client locale, as language-country
     * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticMovieScene(params: { "authorization": string; "clientMovieId": string; "timestamp": number; "acceptLanguage"?: string; "relations"?: boolean; "imageSize"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<Array<Card>> {
        const fetchArgs = DefaultApiFetchParamCreator.getStaticMovieScene(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Stores a card under current user's likes list
     * @summary Add card like
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Requested card ID
     * @param acceptLanguage Client locale, as language-country
     */
    postLikes(params: { "authorization": string; "cardId": string; "acceptLanguage"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<any> {
        const fetchArgs = DefaultApiFetchParamCreator.postLikes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @summary Token endpoint
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token.
     * @param acceptLanguage Client locale, as language-country
     * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: { "authorization": string; "grantType": string; "acceptLanguage"?: string; "deviceId"?: string; "refreshToken"?: string;  }, options?: any): (fetch?: any, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = DefaultApiFetchParamCreator.postToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response: any) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * Removes a card from current user's likes list
     * @summary Delete card like
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Requested card ID
     * @param acceptLanguage Client locale, as language-country
     */
    deleteLikes(params: {  "authorization": string; "cardId": string; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.deleteLikes(params, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieves a full card detail, with no relations or context
     * @summary Full card detail
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Unique identifier for this card
     * @param acceptLanguage Client locale, as language-country
     * @param products Indicates if cards should contain commercial products when available (true) or not (false)
     * @param userData Indicates if cards should contain user data when available (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getCard(params: {  "authorization": string; "cardId": string; "acceptLanguage"?: string; "products"?: boolean; "userData"?: boolean; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getCard(params, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieves a full card detail, and its relations to other cards in a given context (card version)
     * @summary Full card detail with version
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Unique identifier for this card
     * @param version Version identifier, indicates the context where the card is being requested
     * @param acceptLanguage Client locale, as language-country
     * @param products Indicates if cards should contain commercial products when available (true) or not (false)
     * @param userData Indicates if cards should contain user data when available (true) or not (false)
     * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getCardVersion(params: {  "authorization": string; "cardId": string; "version": string; "acceptLanguage"?: string; "products"?: boolean; "userData"?: boolean; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getCardVersion(params, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieves a movie's full card by its client ID, including catalog and cast information
     * @summary Movie catalog info
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     */
    getCatalogMovie(params: {  "authorization": string; "clientMovieId": string; "acceptLanguage"?: string; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getCatalogMovie(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the current and upcoming grid of TV events for the given channel
     * @summary Channel events grid
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     */
    getChannelGrid(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getChannelGrid(params, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
     * @summary Channel movie catalog info
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     */
    getChannelMovie(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getChannelMovie(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a paginated list of cards liked by current user
     * @summary Get card likes
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param acceptLanguage Client locale, as language-country
     * @param imageSize Size of the images returned in the response
     * @param paginateKey Paginate key
     * @param size Number of desired results
     */
    getLikes(params: {  "authorization": string; "acceptLanguage"?: string; "imageSize"?: string; "paginateKey"?: string; "size"?: string; }, options?: any) {
        return DefaultApiFp.getLikes(params, options)(this.fetch, this.basePath);
    }
    /**
     * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
     * @summary Channel sync availability
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelIdList List of client channel IDs as a comma separated list
     * @param acceptLanguage Client locale, as language-country
     */
    getReadyChannels(params: {  "authorization": string; "channelIdList": Array<string>; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.getReadyChannels(params, options)(this.fetch, this.basePath);
    }
    /**
     * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
     * @summary Movie sync availability
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
     * @param acceptLanguage Client locale, as language-country
     */
    getReadyMovies(params: {  "authorization": string; "clientMovieIdList": Array<string>; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.getReadyMovies(params, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieves the list of cards related to the content currently being broadcasted in the given channel
     * @summary Static channel scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param channelId Client channel ID
     * @param acceptLanguage Client locale, as language-country
     * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticChannelScene(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getStaticChannelScene(params, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieves the current list of cards related to the given movie scene
     * @summary Static VOD scene
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param clientMovieId Client movie ID being played
     * @param timestamp Current movie timestamp in seconds
     * @param acceptLanguage Client locale, as language-country
     * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
     * @param imageSize Size of the images returned in the response
     */
    getStaticMovieScene(params: {  "authorization": string; "clientMovieId": string; "timestamp": number; "acceptLanguage"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
        return DefaultApiFp.getStaticMovieScene(params, options)(this.fetch, this.basePath);
    }
    /**
     * Stores a card under current user's likes list
     * @summary Add card like
     * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
     * @param cardId Requested card ID
     * @param acceptLanguage Client locale, as language-country
     */
    postLikes(params: {  "authorization": string; "cardId": string; "acceptLanguage"?: string; }, options?: any) {
        return DefaultApiFp.postLikes(params, options)(this.fetch, this.basePath);
    }
    /**
     * The token endpoint is used to obtain access tokens which allow clients to make API requests
     * @summary Token endpoint
     * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
     * @param grantType Grant type used to obtain the token.
     * @param acceptLanguage Client locale, as language-country
     * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
     * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
     */
    postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "deviceId"?: string; "refreshToken"?: string; }, options?: any) {
        return DefaultApiFp.postToken(params, options)(this.fetch, this.basePath);
    }
}

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (fetch?: any, basePath?: string) {
    return {
        /**
         * Removes a card from current user's likes list
         * @summary Delete card like
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param cardId Requested card ID
         * @param acceptLanguage Client locale, as language-country
         */
        deleteLikes(params: {  "authorization": string; "cardId": string; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.deleteLikes(params, options)(fetch, basePath);
        },
        /**
         * Retrieves a full card detail, with no relations or context
         * @summary Full card detail
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param cardId Unique identifier for this card
         * @param acceptLanguage Client locale, as language-country
         * @param products Indicates if cards should contain commercial products when available (true) or not (false)
         * @param userData Indicates if cards should contain user data when available (true) or not (false)
         * @param imageSize Size of the images returned in the response
         */
        getCard(params: {  "authorization": string; "cardId": string; "acceptLanguage"?: string; "products"?: boolean; "userData"?: boolean; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getCard(params, options)(fetch, basePath);
        },
        /**
         * Retrieves a full card detail, and its relations to other cards in a given context (card version)
         * @summary Full card detail with version
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param cardId Unique identifier for this card
         * @param version Version identifier, indicates the context where the card is being requested
         * @param acceptLanguage Client locale, as language-country
         * @param products Indicates if cards should contain commercial products when available (true) or not (false)
         * @param userData Indicates if cards should contain user data when available (true) or not (false)
         * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
         * @param imageSize Size of the images returned in the response
         */
        getCardVersion(params: {  "authorization": string; "cardId": string; "version": string; "acceptLanguage"?: string; "products"?: boolean; "userData"?: boolean; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getCardVersion(params, options)(fetch, basePath);
        },
        /**
         * Retrieves a movie's full card by its client ID, including catalog and cast information
         * @summary Movie catalog info
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param clientMovieId Client movie ID being played
         * @param acceptLanguage Client locale, as language-country
         * @param imageSize Size of the images returned in the response
         */
        getCatalogMovie(params: {  "authorization": string; "clientMovieId": string; "acceptLanguage"?: string; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getCatalogMovie(params, options)(fetch, basePath);
        },
        /**
         * Returns the current and upcoming grid of TV events for the given channel
         * @summary Channel events grid
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param channelId Client channel ID
         * @param acceptLanguage Client locale, as language-country
         * @param imageSize Size of the images returned in the response
         */
        getChannelGrid(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getChannelGrid(params, options)(fetch, basePath);
        },
        /**
         * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
         * @summary Channel movie catalog info
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param channelId Client channel ID
         * @param acceptLanguage Client locale, as language-country
         * @param imageSize Size of the images returned in the response
         */
        getChannelMovie(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getChannelMovie(params, options)(fetch, basePath);
        },
        /**
         * Returns a paginated list of cards liked by current user
         * @summary Get card likes
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param acceptLanguage Client locale, as language-country
         * @param imageSize Size of the images returned in the response
         * @param paginateKey Paginate key
         * @param size Number of desired results
         */
        getLikes(params: {  "authorization": string; "acceptLanguage"?: string; "imageSize"?: string; "paginateKey"?: string; "size"?: string; }, options?: any) {
            return DefaultApiFp.getLikes(params, options)(fetch, basePath);
        },
        /**
         * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
         * @summary Channel sync availability
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param channelIdList List of client channel IDs as a comma separated list
         * @param acceptLanguage Client locale, as language-country
         */
        getReadyChannels(params: {  "authorization": string; "channelIdList": Array<string>; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.getReadyChannels(params, options)(fetch, basePath);
        },
        /**
         * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
         * @summary Movie sync availability
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
         * @param acceptLanguage Client locale, as language-country
         */
        getReadyMovies(params: {  "authorization": string; "clientMovieIdList": Array<string>; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.getReadyMovies(params, options)(fetch, basePath);
        },
        /**
         * Retrieves the list of cards related to the content currently being broadcasted in the given channel
         * @summary Static channel scene
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param channelId Client channel ID
         * @param acceptLanguage Client locale, as language-country
         * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
         * @param imageSize Size of the images returned in the response
         */
        getStaticChannelScene(params: {  "authorization": string; "channelId": string; "acceptLanguage"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getStaticChannelScene(params, options)(fetch, basePath);
        },
        /**
         * Retrieves the current list of cards related to the given movie scene
         * @summary Static VOD scene
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param clientMovieId Client movie ID being played
         * @param timestamp Current movie timestamp in seconds
         * @param acceptLanguage Client locale, as language-country
         * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
         * @param imageSize Size of the images returned in the response
         */
        getStaticMovieScene(params: {  "authorization": string; "clientMovieId": string; "timestamp": number; "acceptLanguage"?: string; "relations"?: boolean; "imageSize"?: string; }, options?: any) {
            return DefaultApiFp.getStaticMovieScene(params, options)(fetch, basePath);
        },
        /**
         * Stores a card under current user's likes list
         * @summary Add card like
         * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
         * @param cardId Requested card ID
         * @param acceptLanguage Client locale, as language-country
         */
        postLikes(params: {  "authorization": string; "cardId": string; "acceptLanguage"?: string; }, options?: any) {
            return DefaultApiFp.postLikes(params, options)(fetch, basePath);
        },
        /**
         * The token endpoint is used to obtain access tokens which allow clients to make API requests
         * @summary Token endpoint
         * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
         * @param grantType Grant type used to obtain the token.
         * @param acceptLanguage Client locale, as language-country
         * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
         * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
         */
        postToken(params: {  "authorization": string; "grantType": string; "acceptLanguage"?: string; "deviceId"?: string; "refreshToken"?: string; }, options?: any) {
            return DefaultApiFp.postToken(params, options)(fetch, basePath);
        },
    };
};

/**
* CustomAPI - extended object-oriented interface
*/
export class CustomAPI extends DefaultApi {
  public locale: string | null = null;
  private apiKey: string;
  private deviceId: string | null = null;
  private storeTokenType: TokenStoreType = "webstorage";
  private tokenName: string = "dive_token";
  private diveTokenRefreshInterval: number | undefined;
  protected noAuthServices: string[] = [];
  protected environment: string = "PRO";

  constructor(params: { environment: "DEV" | "PRE" | "PRO", tokenName?: string, storeToken?: TokenStoreType, apiKey: string, deviceId?: string | null, fetch?: any, locale?: string | null } = 
    { environment: "PRO", storeToken: "webstorage", tokenName: "dive_token", apiKey: "", deviceId: null, locale: null}) {
    super(params.fetch, BASE_PATH);
    if (params.apiKey === "") {
      console.error("You should provide an apiKey in the params");
      throw new Error("You should provide an apiKey in the params");
    }
    this.apiKey = params.apiKey;
    if (params.deviceId) {
        this.setDeviceId(params.deviceId);
    }
    if (params.environment) {
      this.setEnvironment(params.environment);
    }
    if (params.storeToken) {
      this.storeTokenType = params.storeToken;
    }
    if (params.tokenName) {
      this.tokenName = params.tokenName;
    }
    if (params.locale) {
      this.locale = params.locale;
    }
  }

  public setDeviceId(deviceId: string) {
    this.deviceId = deviceId;
  }

  public setEnvironment(env: "DEV" | "PRE" | "PRO") {
    this.environment = env;
    switch (env) {
        case "DEV":
            this.basePath = BASE_PATH.replace("https://", "https://dev-");
        break;
        case "PRE":
            this.basePath = BASE_PATH.replace("https://", "https://pre-");
        break;
        case "PRO":
        default:
            this.basePath = BASE_PATH;
        break;
    }
  }
  public setLocale(locale: string) {
      this.locale = locale;
  }
  public getLocale() {
      return this.locale;
  }
  public gatherCommonHeaders(params?: any) {
    const newParams: any = {};
    if (!params) {
        params = {};
    }
    if (params["connection"] == null) {
        newParams.connection = "keep-alive";
    }
    if (params["acceptEncoding"] == null) {
        newParams.acceptEncoding = "gzip, deflate";
    }
    if (params["authorization"] == null && this.getSavedToken()) {
        newParams.authorization = `${this.getSavedToken().token_type.substring(0,1).toUpperCase()}${this.getSavedToken().token_type.substring(1)} ${this.getSavedToken().access_token}`;
    } else {
        newParams.authorization = `Basic ${this.apiKey}`;
    }
    /*
    if (params.acceptLanguage == null && this.locale !== null) {
        newParams.acceptLanguage = this.locale;
    }
    if (params["Accept-Language"] == null && this.locale !== null) {
        newParams["Accept-Language"] = this.locale;
    }*/
    /*Trying to set locale*/
    if ( this.locale != null) {
      newParams.acceptLanguage = this.locale;

      if(params.acceptLanguage != null && this.locale !== params.acceptLanguage){
        newParams.acceptLanguage += ',' + params.acceptLanguage;
      }else if(params['Accept-Language'] != null && this.locale !== params.acceptLanguage){
        newParams.acceptLanguage += ',' + params['Accept-Language'];
      }

      params.acceptLanguage = newParams.acceptLanguage;
    }
    return Object.assign({}, newParams, params);
  }
  public writeToken(newToken: AccessToken) {
    if (newToken) {
      switch (this.storeTokenType) {
        case "cookies":
          this.writeTokenToCookie(newToken);
          break;
        default:
          this.writeTokenToWebStorage(newToken);
          break;
      }
      if (this.diveTokenRefreshInterval) {
        window.clearInterval(this.diveTokenRefreshInterval);
        this.diveTokenRefreshInterval = undefined;
      }
      if (newToken.expires_in) {
        this.diveTokenRefreshInterval = window.setInterval(this.refreshToken.bind(this), (Math.max(10000, newToken.expires_in - 60) * 1000) as any); // 60 seconds before expiration (in ms)
      }
    }
  }
  private writeTokenToCookie(newToken: AccessToken) {
    return this.setCookie(this.tokenName, JSON.stringify(newToken), newToken.expires_in!);
  }
  private writeTokenToWebStorage(newToken: AccessToken) {
    if (window.localStorage) {
      window.localStorage.setItem(this.tokenName, JSON.stringify(newToken));
    }
  }
  public deleteSavedToken() {
    switch (this.storeTokenType) {
      case "cookies":
        this.deleteTokenFromCookies();
        break;
      default:
        this.deleteTokenFromWebStorage();
        break;
    }
  }
  private deleteTokenFromWebStorage() {
      if (window.localStorage) {
          window.localStorage.removeItem(this.tokenName);
      }
  }
  private deleteTokenFromCookies() {
    document.cookie = this.tokenName + "=;expires=Thu, 01 Jan 1970 00:00:01 GMT;";
  }
  public getSavedToken() {
    switch (this.storeTokenType) {
      case "cookies":
        return this.getTokenFromCookies();
      default:
        if (this.getTokenFromWebStorage()) {
            return JSON.parse(this.getTokenFromWebStorage() as string);
        }
        break;
    }
  }
  private getTokenFromCookies(): AccessToken | undefined | null {
    const token = this.getCookie(this.tokenName);
    if (token) {
      try {
          return JSON.parse(token) as AccessToken;
      } catch (e) {
          return undefined;
      }
    } else {
      return undefined;
    }
  }
  private getTokenFromWebStorage(): AccessToken | undefined | null {
    if (window.localStorage) {
      try {
        return window.localStorage.getItem(this.tokenName) as AccessToken;
      } catch (e) {
        return undefined;
      }
    }
  }
  public refreshToken() {
    const currToken = this.getSavedToken();
    let auth: string = `Basic ${this.apiKey}`;
    if (currToken && currToken.refresh_token) {
        return this.postTokenAndSave({ grantType: "refresh_token", refreshToken: currToken.refresh_token });
    } else if (this.deviceId) {
        return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
    }
    return Promise.reject("Can not refresh token");
  }
  private getCookie(cname: string) {
    const name = cname + "=";
    const decodedCookie = decodeURIComponent(document.cookie);
    const ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) === 0) {
        return c.substring(name.length, c.length);
      }
    }
    return "";
  }
  private setCookie(cname: string, cvalue: string, exdays: number) {
    const d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    const expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  public postTokenAndSave(params?: {grantType: string, username?: string, password?: string, deviceId?: string, refreshToken?: string}, options?: any) {
    this.deleteSavedToken();
    return new Promise((resolve: any, reject: any) => {
      const newParams: any = Object.assign({}, this.gatherCommonHeaders(params));
      const request = this.postToken(newParams, options);
      request.then((newToken: AccessToken) => {
        this.writeToken(newToken);
        resolve();
      })
      .catch ((e: any) => {
        console.error("Error in postToken from postTokenAndSave", e);
        reject(e);
      });
    });
  }
  /**
  * Delete card like
  * Removes a card from current user&#39;s likes list
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param cardId Requested card ID
  * @param acceptLanguage Client locale, as language-country
  */
  public deleteLikes(params: {  "cardId": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<any>((resolve: any, reject: any) => {
      super.deleteLikes(newParams)
      .then((result: any) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - deleteLikes", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("deleteLikes")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.deleteLikes(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Full card detail
  * Retrieves a full card detail, with no relations or context
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param cardId Unique identifier for this card
  * @param acceptLanguage Client locale, as language-country
  * @param products Indicates if cards should contain commercial products when available (true) or not (false)
  * @param userData Indicates if cards should contain user data when available (true) or not (false)
  * @param imageSize Size of the images returned in the response
  */
  public getCard(params: {  "products"?: boolean; "userData"?: boolean; "imageSize"?: string; "cardId": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Card>((resolve: any, reject: any) => {
      super.getCard(newParams)
      .then((result: Card) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getCard", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getCard")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getCard(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Full card detail with version
  * Retrieves a full card detail, and its relations to other cards in a given context (card version)
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param cardId Unique identifier for this card
  * @param version Version identifier, indicates the context where the card is being requested
  * @param acceptLanguage Client locale, as language-country
  * @param products Indicates if cards should contain commercial products when available (true) or not (false)
  * @param userData Indicates if cards should contain user data when available (true) or not (false)
  * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
  * @param imageSize Size of the images returned in the response
  */
  public getCardVersion(params: {  "products"?: boolean; "userData"?: boolean; "relations"?: boolean; "imageSize"?: string; "cardId": string; "version": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Card>((resolve: any, reject: any) => {
      super.getCardVersion(newParams)
      .then((result: Card) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getCardVersion", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getCardVersion")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getCardVersion(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Movie catalog info
  * Retrieves a movie&#39;s full card by its client ID, including catalog and cast information
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param clientMovieId Client movie ID being played
  * @param acceptLanguage Client locale, as language-country
  * @param imageSize Size of the images returned in the response
  */
  public getCatalogMovie(params: {  "imageSize"?: string; "clientMovieId": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Card>((resolve: any, reject: any) => {
      super.getCatalogMovie(newParams)
      .then((result: Card) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getCatalogMovie", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getCatalogMovie")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getCatalogMovie(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Channel events grid
  * Returns the current and upcoming grid of TV events for the given channel
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param channelId Client channel ID
  * @param acceptLanguage Client locale, as language-country
  * @param imageSize Size of the images returned in the response
  */
  public getChannelGrid(params: {  "imageSize"?: string; "channelId": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<TvGrid>((resolve: any, reject: any) => {
      super.getChannelGrid(newParams)
      .then((result: TvGrid) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getChannelGrid", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getChannelGrid")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getChannelGrid(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Channel movie catalog info
  * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param channelId Client channel ID
  * @param acceptLanguage Client locale, as language-country
  * @param imageSize Size of the images returned in the response
  */
  public getChannelMovie(params: {  "imageSize"?: string; "channelId": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Card>((resolve: any, reject: any) => {
      super.getChannelMovie(newParams)
      .then((result: Card) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getChannelMovie", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getChannelMovie")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getChannelMovie(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Get card likes
  * Returns a paginated list of cards liked by current user
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param acceptLanguage Client locale, as language-country
  * @param imageSize Size of the images returned in the response
  * @param paginateKey Paginate key
  * @param size Number of desired results
  */
  public getLikes(params: {  "imageSize"?: string; "paginateKey"?: string; "size"?: string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<Card>>((resolve: any, reject: any) => {
      super.getLikes(newParams)
      .then((result: Array<Card>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getLikes", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getLikes")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getLikes(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Channel sync availability
  * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param channelIdList List of client channel IDs as a comma separated list
  * @param acceptLanguage Client locale, as language-country
  */
  public getReadyChannels(params: {  "channelIdList": Array<string>; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<ChannelStatus>>((resolve: any, reject: any) => {
      super.getReadyChannels(newParams)
      .then((result: Array<ChannelStatus>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getReadyChannels", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getReadyChannels")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getReadyChannels(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Movie sync availability
  * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
  * @param acceptLanguage Client locale, as language-country
  */
  public getReadyMovies(params: {  "clientMovieIdList": Array<string>; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<MovieStatus>>((resolve: any, reject: any) => {
      super.getReadyMovies(newParams)
      .then((result: Array<MovieStatus>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getReadyMovies", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getReadyMovies")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getReadyMovies(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Static channel scene
  * Retrieves the list of cards related to the content currently being broadcasted in the given channel
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param channelId Client channel ID
  * @param acceptLanguage Client locale, as language-country
  * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
  * @param imageSize Size of the images returned in the response
  */
  public getStaticChannelScene(params: {  "relations"?: boolean; "imageSize"?: string; "channelId": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<Card>>((resolve: any, reject: any) => {
      super.getStaticChannelScene(newParams)
      .then((result: Array<Card>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getStaticChannelScene", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getStaticChannelScene")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getStaticChannelScene(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Static VOD scene
  * Retrieves the current list of cards related to the given movie scene
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param clientMovieId Client movie ID being played
  * @param timestamp Current movie timestamp in seconds
  * @param acceptLanguage Client locale, as language-country
  * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
  * @param imageSize Size of the images returned in the response
  */
  public getStaticMovieScene(params: {  "relations"?: boolean; "imageSize"?: string; "clientMovieId": string; "timestamp": number; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<Array<Card>>((resolve: any, reject: any) => {
      super.getStaticMovieScene(newParams)
      .then((result: Array<Card>) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - getStaticMovieScene", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("getStaticMovieScene")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.getStaticMovieScene(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Add card like
  * Stores a card under current user&#39;s likes list
  * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
  * @param cardId Requested card ID
  * @param acceptLanguage Client locale, as language-country
  */
  public postLikes(params: {  "cardId": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<any>((resolve: any, reject: any) => {
      super.postLikes(newParams)
      .then((result: any) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - postLikes", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("postLikes")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.postLikes(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  /**
  * Token endpoint
  * The token endpoint is used to obtain access tokens which allow clients to make API requests
  * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
  * @param grantType Grant type used to obtain the token.
  * @param acceptLanguage Client locale, as language-country
  * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
  * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
  */
  public postToken(params: {  "deviceId"?: string; "refreshToken"?: string; "grantType": string; }, options?: any) {
    let newParams: any = this.gatherCommonHeaders(params);
    return new Promise<AccessToken>((resolve: any, reject: any) => {
      super.postToken(newParams)
      .then((result: AccessToken) => {
        resolve(result);
      })
      .catch ((error: any) => {
        if (error) {
            console.log("%c REST error - postToken", "background: black; color: #FE2EF7; padding: 0 10px;", error);
        }
        if (error.status === 401 && this.serviceRequiresToken("postToken")) {
            this.refreshToken()
            .catch ((error: any) => {
              if (this.deviceId) {
                return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
              } else {
                throw new Error("Can not refresh token (no device id)");
              }
            })
            .then(() => {
              newParams = this.gatherCommonHeaders(params);
              return super.postToken(newParams);
            })
            .then((result: any) => {
              resolve(result);
            })
            .catch ((errorRefreshingToken: any) => {
              console.error('Error refreshing token', errorRefreshingToken);
              reject(errorRefreshingToken);
            });
        } else {
            reject(error);
        }
      });
    });
  }
  private serviceRequiresToken(methodName: string) {
    return this.noAuthServices.indexOf(methodName) === -1;
  }
}
